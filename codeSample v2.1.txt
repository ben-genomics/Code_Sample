'''Combine VCFs (version 3.1), last modified 08/17/17Benjamin Kaplan â€“ Bioinformatics Core Services (BiCS), Target Discovery GroupSupervisor: Christian Buhay* This code is the property of Regeneron Pharmaceuticals.* Permission was granted by BiCS head Alejo Mujica and the Regeneron Legal* Department for distribution by Benjamin Kaplan for purposes of recruitment.Combine VCFs intelligently combines multiple VCF (Variant Call Format) filesof the same, similar or different strain. E.g. Combine VCFs can be called onseveral VCF files generated from different mice of the same Regeneronproprietary strain in order to obtain a consensus "true" VCF.Combine VCF takes in a list of VCF files (and optionally, a configuration TSVfile specifying criteria for filtering intersecting records, else the criteria is generated automatically). The VCF files are combined via a series of callsupon Bcftools (newer versions only) resulting in a main consensus VCF file. Additionally, the number of records in relevant file intersections is noted and optionally the user may choose to keep certain intersection-VCF files created tofurther construct the consensus VCF.The combination step consists of obtaining all VCF records meeting the criteriaof sufficient quality with respect to both the number of VCF files the recordwas found in and the total number of VCF files being combined. I.e. records thathave high quality (as measured by quantities such as Depth and Phred QualityDepth) and appear in more VCFs are consequently more likely to be true positivesand are thus included in the consensus VCF, whereas records that appear sparselyand/or have lower read qualities are more likely to have been false positivesand are thus not included in the consensus VCF.E.g. the automatically generated criteria for records that appear in exactly 2 out of 3 VCFs would be "DP>=24 && QD>=30.0" (depth/number of reads must exceed24 and the quality-depth must exceed 30.0") and for a records that appear in 3 out of 5 VCFs, the criteria is "DP>=20 && QD>=18.0."Combine VCFs is intended to be ran only on occasion with typically 3 to 5 VCFfiles, higher amounts are expected. Runtime averages around ~15 minutes on the Sun Grid System cluster and though can push 40 minutes for larger combinations.'''import subprocessimport argparseimport timeimport sysimport osos.system("module load bcftools/1.5")def readFile(filePath):    '''Reads text based file from given file path'''    with open(filePath, "rt") as f:        return f.read()def writeFile(filePath, contents):    '''Writes "contents" string to text based file with path "filePath"'''    with open(filePath, "wt") as f:        f.write(contents)# This function should be well-scrutinized and modified as seen fitdef autoF(N, n):    '''Automatically generates and returns an inlcusionary filtering expression    based on the values of inputs N (number of files being intersected) and n    (exact number of files record must intersect in)'''    if (n > N):        raise RunTimeError("Number of file appearences of a record cannot " +                            "exceed number of files present")    def genDpThreshold(N, n):        '''Generates minimum DP threshold for filtering based on N and n        Variable values were chosen arbitrary and may be subject to revision'''                baseDpThreshold = 30                nonAppearancePenalty = 5        nonAppearances = N - n                totalNonAppearancePenalty = nonAppearances * nonAppearancePenalty        multiAppearanceFactor = 0.7        appearancesMultiplier = multiAppearanceFactor ** (n - 1)        DpThreshold = (  (baseDpThreshold + totalNonAppearancePenalty)                        * appearancesMultiplier  )        return int(round(DpThreshold))    def genQdThreshold(N, n):        '''Generates minimum Quality Depth (QD) threshold for filtering based on         N and n Variable.        Values were chosen arbitrary and may be subject to revision'''        baseQdThreshold = 50                multiAppearanceFactor = 0.6        appearanceMultiplier = multiAppearanceFactor ** (n - 1)        QdThreshold = baseQdThreshold * appearanceMultiplier        return round(QdThreshold, 2)    DpThreshold = str(genDpThreshold(N, n))    QdThreshold  = str(genQdThreshold(N, n))    fliterExpression = "\"DP>="+DpThreshold + " && " + "QD>="+QdThreshold +"\""    return fliterExpressiondef getManual(manualControlConfigTsvFilePath):    '''Creates and returns a function that takes in two paramaters: N (number of    files being intersected) and n (exact number of files record must intersect    in) and returns an inlcusionary filtering expression extracted from row=N,    col=n of the manually created filter control configuration TSV)'''    configTSV = readFile(manualControlConfigTsvFilePath)    configArray = [(ln.split("\t")) for ln in configTSV.splitlines()]    def manualF(N, n):        '''Function to be returned, as specified above'''        if (n > N):            raise RunTimeError("Number of file appearences of a record  " +                                "cannot exceed number of files present")        filterExpression = "\""+configArray[N][n]+"\""        return filterExpression    return manualFdef processArgs(args):    '''Processes arguments given to combineVCF.py from the command line or    another script. Returns a list of all VCF file paths, a function to be used    for generating inclusionary filtering expressions, and an output path    specifying either an existing directory or a file path in an existing     directory to write output too.'''    doAuto = False    doManual = False    keepCombineDirs = False        VCFs = []    outputPath = os.getcwd()        # Iterates through list of arguments looking for VCF files, a --manual tag    # followed by a tsv file filtering level configuration file or just an     # --auto tag, and optionally an output path    argIndex = 1    while (argIndex < len(args)):        if (args[argIndex] == "--auto"):  # --auto tag is unnecessary but can            doAuto = True                 # can clarify input            argIndex += 1            continue        elif (args[argIndex] == "--keepDirs"):            keepCombineDirs = True            argIndex += 1            continue                elif (args[argIndex] == "--manual"):            doManual = True            try:                manualF = getManual(args[argIndex + 1])                argIndex += 2            except:                if (argIndex + 1 == len(args)): raise Exception(                    "Manual control tsv must come after --manual")                if (args[argIndex+1]).endswith(".vcf.gz"): raise Exception(                    "Manual control tsv must come after --manual")                raise RunTimeError("Failure to parse manual filter config " +                                    "file" + args[argIndex + 1])        elif (args[argIndex] == "--op" or args[argIndex] == "--outPath"):            try:                outputPath = args[argIndex + 1]                argIndex += 2            except:                raise Exception(                    "Please specify output path after --op or --outPath")        elif (args[argIndex]).endswith(".vcf.gz"):            VCFs.append(args[argIndex])            argIndex += 1        else:            raise Exception("File: " + args[argIndex] +                              " isn't a bgzipped VCF (.vcf.gz) or recognized tag")    if (doAuto == True and doManual == True):        raise Exception("Error: Filtering Control Unclear.\n" +              "Both --auto and --manual flags were given. Only one may be used")    if (doManual == True):        return (VCFs, manualF, outputPath, keepCombineDirs)    else:  # Note that autoF is the default if --manual is not tagged        return (VCFs, autoF, outputPath, keepCombineDirs)        #  keepCombineDirs is set to false by default as welldef processOutputPath(outputPath):    '''Processes output path and returns an output directory path and output    file path. If output path is a directory, then the returned output directory    will be the outputPath paramater, and the output file path will be     output directory + "/" + combined.vcf.gz"    Raises error if an improper outputPath is given or the output dir does not    exist'''    if os.path.isdir(outputPath):        outDir, outFile = outputPath, outputPath.rstrip("/")+"/combined.vcf.gz"    else:        outDir, outFile = os.path.dirname(outputPath), outputPath    if (not os.path.isdir(outDir)):        raise NotADirectoryError("No directory was found for: " + outputPath)    else:        return outDir, outFiledef genBitstrings(N, n):    '''Generates and returns list of all possible bitstrings of length N    containing n ones'''    def genBitstringsHelper(length, onesPlaced, build):        if (length == N):            return [build]        if (onesPlaced == n):            return [build + "0"*(N-length)]                    else:            if1 = genBitstringsHelper(length + 1, onesPlaced + 1, build + "1")        if (n - onesPlaced) == (N - length):            return [build + "1"*(N-length)]                    else:            if0 = genBitstringsHelper(length + 1, onesPlaced, build + "0")                    return (if1 + if0)    return genBitstringsHelper(0, 0, "")def logIsecs(N, VCFs, F, outDir):    '''Creates a log file for all intersecting permutations of the given VCFs    fileted for records that ended up appearing in the final combined VCF'''    logFile = outDir+"/isecLog.tsv"    writeFile(logFile, "")    for n in range(N, 0, -1):        bitstrings = genBitstrings(N, n)        if (n == 1):  # Special case allowing for faster processing            isecsDir = outDir+"/combine_n=1"            for file in sorted(os.listdir(isecsDir)):                filePath = isecsDir + "/" + file                if (file.endswith(".vcf.gz") and                     file.startswith("filtered_")):                    try:                        i = int((file.lstrip("filtered_")).rstrip(".vcf.gz"))                    except:                        continue                    assert(bitstrings[i]) == "0"*(i) + "1" + "0"*(N - i - 1)                    writeFile(logFile, readFile(logFile)                                       + VCFs[i] + '\t'                                       + bitstrings[i] + '\t')                    os.system("bcftools view -H " + filePath +                              " | wc -l >> " + logFile)        else:  # Each bitstring corresponds to a subset of the VCFs intersecting            isecsDir = outDir+"/combine_n="+str(n)            fileList = []            for file in sorted(os.listdir(isecsDir)):                if (file.endswith(".vcf.gz") and file.startswith("filtered_")):                    fileList.append(isecsDir + "/" + file)            for bitstring in bitstrings:                theseVCFs = [fileList[i] for i in range(len(bitstring))                                if (bitstring[i] == '1')]                thoseVCFs = [VCFs[i] for i in range(len(bitstring))                                if (bitstring[i] == '1')]                writeFile(logFile, readFile(logFile)                                   + ", ".join(thoseVCFs) + '\t'                                   + bitstring + '\t')                                os.system("bcftools isec -i " + F(N, n) + " -n~"+bitstring + " "                          + (" ".join(theseVCFs)) + " | wc -l >> " + logFile)def combineVCFs(VCFs, F, outDir, outFile, keepCombineDirs=False):    '''Combines VCFs from the list by first obtaining intersections of all    records that appear once, intersections of all records that appear twice,    and so on up to the intersection of all records that appear N times.    Next, combineVCFs filters each of the intersection VCFs based on the number     of VCFs and their respective n-level.    Finally, merge will merge all the filtered VCFs, whose records were deemed    suitablly "true" based on the filtering criteria, and output a single     combined VCF file, denoted by the outFile path, and save it in the outDir    directory.'''        N = len(VCFs)    mergeList = []    wipeDirs = []        scriptsDir = os.path.dirname(os.path.realpath(__file__)) # This script's dir    filterScript = "FilterVCF_v1.3.sh"    Filter = scriptsDir + "/" + filterScript    # Cycle trough each n-level from 1 to N and calculate intersections of    # records that appear in n files. Then filter each intersection via F(N, n)    for n in range(N, 0, -1):        isecsDir = outDir + "/" + "combine_n="+str(n)        wipeDirs.append(isecsDir)        os.system("bcftools isec -O z -n=" + str(n) + " " + (" ".join(VCFs)) +                   " -p " + isecsDir)        for file in os.listdir(isecsDir):            filePath = isecsDir + "/" + file            filteredFilePath = isecsDir+"/filtered_"+file            if file.endswith(".vcf.gz"):                filterFileCmd = ("bash " + Filter + " -i " + F(N, n)                     + " -v "+ filePath + " -p " + isecsDir)                               os.system(filterFileCmd)                os.system("bcftools index -f " + filteredFilePath)                mergeList.append(filteredFilePath)    # Merges all VCF files filtered for passing merging criteria    os.system("bcftools merge --force-samples -m all " +               " ".join(mergeList) + " -O z -o " + outFile)    logIsecs(N, VCFs, F, outDir)        # Unless --keepCombineDirs flag is incliuded,    # removes all extraneous directories and files used to build merge    if (keepCombineDirs == False):        for extraneousDir in wipeDirs:            os.system("rm " + extraneousDir+"/*" )            os.system("rmdir " + extraneousDir)def main():    '''Main function, calls processArgs, processes the outputPath, and calls    combineVCFs'''        # Get list of arguments given with combine.py's command line call     args = sys.argv        # Get list of all bgzipped VCF files being combined, the filter expression    # generator F, and the output path    # (VCFs, F, outputPath, keepCombineDirs) = processArgs(args)    (VCFs, F, outputPath, keepCombineDirs) = processArgs(args)    # Parse the output path into the output directory and the output file path    outDir, outFile = processOutputPath(outputPath)    # Combine VCF files together using BCFtools intersection, an (intelligently)    # designed filtering function, and BCFtools merge    combineVCFs(VCFs, F, outDir, outFile, keepCombineDirs)if __name__ == "__main__":    t1 = time.time()    main()    t2 = time.time()    print("Time taken: " + str(t2 - t1))